package org.lessons.java.final_project_java_spring_react.model;

import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "orders")
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // Auto-generated by @PrePersist when order is first saved to database
    private LocalDateTime orderDate;

    // Calculated field - do not set manually, use calculateTotalPrice()
    private BigDecimal totalPrice;

    @NotBlank(message = "Payment status is required")
    @Pattern(regexp = "PENDING|COMPLETED|FAILED|REFUNDED", message = "Invalid payment status")
    private String paymentStatus = "PENDING";

    // For Stripe test mode: store "card" or Stripe payment method ID
    private String paymentMethod;

    // Stripe payment intent ID for tracking
    private String stripePaymentIntentId;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    @JsonBackReference("user-orders")
    private User user;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
    private List<GameKey> gameKeys;

    // Constructors
    public Order() {
    }

    // Auto-generate orderDate when entity is first persisted
    @PrePersist
    protected void onCreate() {
        if (orderDate == null) {
            orderDate = LocalDateTime.now();
        }
    }

    public Order(User user, BigDecimal totalPrice) {
        this.user = user;
        this.totalPrice = totalPrice;
    }

    // Getters and Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public LocalDateTime getOrderDate() {
        return orderDate;
    }

    public BigDecimal getTotalPrice() {
        return totalPrice;
    }

    public String getPaymentStatus() {
        return paymentStatus;
    }

    public void setPaymentStatus(String paymentStatus) {
        this.paymentStatus = paymentStatus;
    }

    public String getPaymentMethod() {
        return paymentMethod;
    }

    public void setPaymentMethod(String paymentMethod) {
        this.paymentMethod = paymentMethod;
    }

    public String getStripePaymentIntentId() {
        return stripePaymentIntentId;
    }

    public void setStripePaymentIntentId(String stripePaymentIntentId) {
        this.stripePaymentIntentId = stripePaymentIntentId;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public List<GameKey> getGameKeys() {
        return gameKeys;
    }

    public void setGameKeys(List<GameKey> gameKeys) {
        this.gameKeys = gameKeys;
    }

    // Calculate total price from game keys with discounts applied
    public void calculateTotalPrice() {
        if (gameKeys == null || gameKeys.isEmpty()) {
            this.totalPrice = BigDecimal.ZERO;
            return;
        }

        BigDecimal total = BigDecimal.ZERO;
        for (GameKey key : gameKeys) {
            Game game = key.getGame();
            BigDecimal gamePrice = BigDecimal.valueOf(game.getPrice());

            // Apply discount if present
            if (game.getDiscountPercentage() != null && game.getDiscountPercentage() > 0) {
                BigDecimal discount = BigDecimal.valueOf(game.getDiscountPercentage())
                        .divide(BigDecimal.valueOf(100));
                BigDecimal discountAmount = gamePrice.multiply(discount);
                gamePrice = gamePrice.subtract(discountAmount);
            }

            total = total.add(gamePrice);
        }

        this.totalPrice = total.setScale(2, RoundingMode.HALF_UP);
    }
}
